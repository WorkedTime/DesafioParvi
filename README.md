# **Desafio - RPA Python - Grupo Parvi**

Etapas do Desafio
1. **Web Scraping com Selenium**
2. **Processamento de Dados com Pandas**
3. **Envio de Relat√≥rio por E-mail (Extra)**

## **Passo 1: Configurando o Ambiente de Desenvolvimento**

### **1.1 Instalei o python**
Via site: https://www.python.org/
Baixei a vers√£o 3.13.3

### **1.2 Configurei o VS Code**
Realizei a instala√ß√£o do `pip` no terminal:
```bash
python -m ensurepip --default-pip
```
Verifiquei a instala√ß√£o e a vers√£o:
```bash
pip --version
```

### **1.3 Criei um Ambiente Virtual**
Dentro do diret√≥rio do projeto, abri um terminal e executei o seguinte comando (√© necessario o venv para executar o projeto):
```bash
python -m venv venv
```
Ativei o ambiente:
  ```bash
  venv\Scripts\activate
  pip install -r requeriments.txt
  ```

### **1.4 Instalei as Depend√™ncias**
Instalei as bibliotecas utiizando os seguintes comandos:
```bash
pip install selenium pandas python-dotenv webdriver-manager
```
Gerei o arquivo `requeriments.txt`:
```bash
pip freeze > requeriments.txt
```

## **Passo 2: Estruturei o Projeto**
Crie a seguinte estrutura de diret√≥rios para deixar o projeto mais organizado:
```
üìÇ RPA_Quotes
 ‚î£ üìÇ data              # Pasta armazenando o arquivo CSV que foi gerado
 ‚î£ üìú citacoes.csv      # Armazenamento gerado dos arquivos de busca no CSV (Dentro da pasta data)   
 ‚î£ üìÇ venv              # Ambiente virtual
 ‚î£ üìú .env              # Credenciais para envio de e-mail
 ‚î£ üìú .env.examples     # Credenciais n√£o reais para exemplo de e-mail para o git  
 ‚î£ üìú .gitignore        # Biblioteca git para n√£o uso de dados sens√≠veis dos usu√°rios e desenvolvedor
 ‚î£ üìú main.py           # Arquivo principal do projeto
 ‚î£ üìú README.md         # Instru√ß√µes do projeto
 ‚î£ üìú requirements.txt  # Depend√™ncias
```

## **Passo 3: Implementei Web Scraping com Selenium**
Crie o arquivo `main.py` e adicione todos os imports e suas refer√™ncias para busca dos dados, cria√ß√£o do CSV com o que foi buscado
e envio via e-mail dos dados lidos e filtrados, como seguem abaixo:

```python 3.13.3

import csv
import os 

import ast
import pandas as pd
import smtplib

from dotenv import load_dotenv
from email.message import EmailMessage
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import NoSuchElementException, TimeoutException
from webdriver_manager.chrome import ChromeDriverManager

#Part I - Busca de dadps via URL e filtro de buscas

#1.Instala√ß√£o do driver do Chrome, al√©m de baixar a vers√£o mais recente para a sua m√°quina, iniciando o navegador e se conectando ao Selenium.
#2.Acesso ao site com o driver.get e armazenando na lista quote_lists, executando o script em loop enquanto verdadeiro para encontro das cita√ß√µes por busca de elementos via name,tamb√©m manusendo com uso de except para qualquer erro de busca.
#3.Click de bot√£o next para perman√™ncia de buscas em outras p√°ginas do mesmo site.
#4.Tratativa de erro caso a busca falhe, al√©m de aviso e encerramento vis√≠vel da fun√ß√£o.
#5.Cria o arquivo (csv)
#6.Encerramento do Driver.   

def encontrando_dados():

    service = Service(ChromeDriverManager().install()) #Faz download ou encontra o ChromeDriver adequado a vers√£ instalada no sistema
    driver = webdriver.Chrome(service=service) #ChromeDriver -> Service que inicializa o navegador Chrome e se conecta ao Selenium parmitindo as automa√ß√µes

    driver.get("https://quotes.toscrape.com/js-delayed/") #Acessa o site de busca de informa√ß√µes

    quotes_list = [] #Lista para armazenar as cita√ß√µes

    while True: #Executa enquanto o loop se mostrar verdadeiro
        try:

            WebDriverWait(driver, 10).until(EC.presence_of_all_elements_located((By.CLASS_NAME, "quote"))) #Aguarda at√© que as cita√ß√µes sejam carregadas

            #Coleta as cita√ß√µes na p√°gina atual
            quotes = driver.find_elements(By.CLASS_NAME, "quote") #Encontra elementos com o nome "quote"
            for quote in quotes: #Loop for para repeti√ß√£o de busca
                #texts = [texto.text for texto in quote.find_elements(By.CLASS_NAME, "text")] #Encontra elementos com o nome "text"
                texts = [texto.text for texto in quote.find_elements(By.CLASS_NAME, "text")]
                author = quote.find_element(By.CLASS_NAME, "author").text #Encontra elementos com o nome "author"
                tags = [tag.text for tag in quote.find_elements(By.CLASS_NAME, "tag")]
                quotes_list.append((texts, author, tags)) #Adiciona a lista as tabelas "tag", "text" e "author"
                print(f"{texts} - {author} - {tags}") #Mostra aquilo que est√° sendo encontrado nas tabelas de "text", "author" e "tag"

            #Tenta encontrar o bot√£o "Next"
            next_button = driver.find_element(By.CSS_SELECTOR, 'li.next > a') #Encontra e retorna um elemento <a>(link) que est√° dentro de um <li>(lista) com classe next(p√°gina ou item em lista)
            next_button.click() #Faz a p√°gina sucessora ser clicada

        except (NoSuchElementException, TimeoutException):  #Erros que podem gerar esgotamento de tempo e de nenhum elemento encontrado
            print("Navega√ß√£o finalizada ou erro ao carregar a pr√≥xima p√°gina.") #Aviso sobra a detec√ß√£o de erro
            break #Da parada a fun√ß√£o independente do que aconte√ßa

    driver.quit() #Encerramento de Driver

    print(f"\nTotal de cita√ß√µes coletadas: {len(quotes_list)}") #Exibe o total de cita√ß√µes extra√≠das

    with open("data/citacoes.csv", mode="w", newline="", encoding="utf-8") as arquivo_csv: # with open forma de abrir e fechar arquivo de forma segura mesmo que ocorra erro | 'w' abre o arquivo no modo escrita e sobrescreve ou cria um novo | newline exita linhas em brancos extras | utf-8 define a codifica√ß√£o garantindo acentua√ß√£o e caracteres especiais | as arquivo_csv representa o objeto do arquivo aberto
        writer = csv.writer(arquivo_csv) #Fun√ß√£o csv que cria um objeto gravador para escrita de dados | arquivo_csv √© onde sera armazenado os dados | escreve linhas no arquivo csv 
        writer.writerow(["Texto", "Autor", "Tags"]) #Cabe√ßalhos do arquivo.csv
        writer.writerows(quotes_list) #Escreve as linhas recebidas do arquivo gerado pela lista de busca

    print("\nArquivo csv gerado com sucesso!")

encontrando_dados()

#Part II - Lendo arquivo CSV p√≥s criado e tornando em lista literal

#1.L√™ o arquivo(csv) e filtra por contagem(value_counts), maior repeti√ß√£o(idxmax), por lista(ast.literal_eval), por palavras inteiras(ast.literal_eval) e coloca como upper a primeira letra das palavras listadas no arquivo(csv) criado  
#2.Imprime para o usu√°rio o autor e tag mais frequentes dentro do arquivo(csv) gerado


def processando_dados():

    df = pd.read_csv("data/citacoes.csv") #Determina que o DataFrame do Pandas busque e leia o arquivo csv gerado acima

    total_quotes = df["Texto"].value_counts().count() #L√™ os dados da coluna "Texto" no DataFrame e conta cada uma delas na lista
    print(f"\nQuantidade total de cita√ß√µes: {total_quotes}") #Mostra a contagem de cita√ß√µes/textos

    autor_mais_frequente = df["Autor"].value_counts().idxmax() #L√™ os dados na coluna "Autor" no DataFrame e conta cada valor separadamente e tamb√©m guarda o mais repetido
    print(f"Autor mais recorrente: {autor_mais_frequente}") #Mostra o resultado p√≥s filtro do dado final

    tag_mais_frequente = df["Tags"].apply(ast.literal_eval).explode().str.capitalize().value_counts().idxmax() #L√™ os dados na coluna "Tags " do DataFrame e aplica a cada coluna uma forma segura de ler os dados como uma lista ou dicion√°rio validando-os, depois os separa e l√™ cada uma das palavras armazenadas, al√©m de deixar a primeira letra de cada palavra impressa mai√∫scula e fazendo sua contagem, revelando tamb√©m a tag mais repetida
    print(f"Tag mais utilizada: {tag_mais_frequente}\n") #Mostra o resultado p√≥s filtro acima do dado final

    return { #Usado para retornar os dados filtrados e processados para serem usados posteriormente
    'Citacoes':int(total_quotes),
    'Autor':autor_mais_frequente,
    'Tag':tag_mais_frequente
    }

processando_dados()

#Parte III - Enviando o relat√≥rio via e-mail (Extra)
load_dotenv()

#1.Estabele o envio de dados(csv) para os destinat√°rios inclusos no (.env) por meio de senha gerada pela google para a plataforma de envio e corpo de e-mail definido para se evitar erros
#2.Envio de aviso caso o arquivo (csv) n√£o seja encontrado

def enviar_email():

    total = processando_dados() #Uso da fun√ß√£o processando_dados para obter os dados filtrados e processados
    citacoes = (total["Citacoes"])
    autor = (total["Autor"])
    tags = (total["Tag"])

    user = os.getenv("EMAIL") #Obt√©m o e-mail do remetente a partir do arquivo .env
    password = os.getenv("PASS") #Obt√©m a senha do remetente a partir do arquivo .env
    email_list = os.getenv("EMAIL_LIST") #Obt√©m a lista de e-mails do destinat√°rio a partir do arquivo .env

    if email_list: #Verifica se a vari√°vel est√° definida
        emails = email_list.split(",") #Cria a lista de e-mails usando o delimitador (v√≠rgula neste caso)

        for email in emails: # Remove espa√ßos em branco desnecess√°rios
            print(f"Sucesso! Enviado para: {email_list}") #Exibe a lista de e-mails que receber√£o o relat√≥rio
    else:
        print("A vari√°vel EMAIL_LIST n√£o foi definida no arquivo .env.") #Exibe mensagem de erro caso a vari√°vel n√£o esteja definida

    if not user or not password:
        print("Erro: EMAIL ou PASS n√£o est√£o definidos no .env") #Exibe mensagem de erro caso o e-mail ou a senha n√£o estejam definidos no arquivo .env
        return

    #Envio de e-mail sendo remetente, destinat√°rio e corpo da mensagem definidos
    msg = EmailMessage() #Cria uma mensagem de e-mail
    msg['Subject'] = 'Relat√≥rio de Cita√ß√µes'
    msg['From'] = user
    msg['To'] = email_list
    msg.set_content(f"O valor total gerado no arquivo csv √© de: {citacoes} Cita√ß√µes\n O autor mais recorrente √©: {autor}\n A tag mais utilizada √©: {tags}") #Define o conte√∫do do e-mail com os dados filtrados

    try:
        with open("data/citacoes.csv", "rb") as f: #Abre o arquivo csv em modo leitura bin√°ria
            msg.add_attachment(f.read(), maintype='application', subtype='csv', filename="citacoes.csv") #Adiciona o arquivo como anexo √† mensagem de e-mail
    except FileNotFoundError:
        print("Erro! Arquivo csv n√£o encontrado.") #Exibe mensagem de erro caso o arquivo csv n√£o seja encontrado
        return

    try:
        with smtplib.SMTP_SSL('smtp.gmail.com', 465) as smtp: #Cria uma conex√£o segura com o servidor SMTP do Gmail
            smtp.login(user, password) #Faz login no servidor SMTP usando o e-mail e a senha
            smtp.send_message(msg) #Envia a mensagem de e-mail
            print("\nE-mail enviado com sucesso!")
    except Exception as e: #Exce√ß√£o para capturar erros durante o envio do e-mail
        print(f"Falha ao enviar e-mail! \n {e}")

enviar_email()

```

## **Passo 6: Ap√≥s finalizar todo o andamento do projeto, versionei ele no meu git**
Realizei a insala√ß√£o e configura√ß√£o do git na minha maquina
Iniciei o git:
```bash
git init
```
Realizei o primeiro commit:
```bash
git commit -m "Parvi commit"
```
Adicionei o reposit√≥rio:
```bash
git remote add origin https://github.com/WorkedTime/DesafioParvi.git
git branch -M main
git push -u origin main --force
```
Link do Repositorio do Git (https://github.com/WorkedTime/DesafioParvi.git)
